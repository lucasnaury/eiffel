#!/usr/bin/python3
"""Basic control of the robot, move forward and avoid obstacles. Doesn't get stuck"""

# imports
import rclpy
import math as m
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped, PoseWithCovarianceStamped, Twist
from std_msgs.msg import String
import time, threading

# main class
class RobotLogic(Node):
    
    def __init__(self, name="robot_logic", timerFreq = 1/60.0):
        """ constructor """
        super().__init__(name)  # Create the node

        # Initialize parameters
        self.point0 = [[-0.45803, -2.6858], [-0.37842, 0.92563]]
        self.pointA = [[1.9641, -1.8761], [0.37684,0.9273]]

        # Initialize subscribers
        self.create_subscription(String, 'ned2', self.robot_full_callback, 10)
        self.create_subscription(Twist, 'multi/cmd_nav', self.robot_vel_callback, 10)

        # Initialize a publisher
        self._goal_publisher = self.create_publisher(PoseStamped, 'goal_pose', 10)
        self._initialpose_publisher = self.create_publisher(PoseWithCovarianceStamped, 'initialpose', 10)

        # Initialize a clock for the publisher
        # self.create_timer(timerFreq, self.publish_velo)

        # Initialize variables
        self._timerFreq = timerFreq
        self._previousScanTime = None
        self._points = []
        self._firstPointSeen = None
        self._moving = False


        # Setup Initial pose to the A point
        initialPoseWithCovariance = self.pointToPoseWithCovarianceStamped(self.point0)
        self._initialpose_publisher.publish(initialPoseWithCovariance)

    # When the map is loaded, move next to the Ned2 robot
    def moveTo0(self):
        print("try move back")
        # while self._moving:
        #     pass

        self.moveToPosition(self.point0)
        print("move back")

    def robot_full_callback(self, msg):

        # Only move if not already moving
        if not self._moving:
            print('Robot full, go to A')
            # When the robot is full, move to the A point
            self.moveToPosition(self.pointA)

            # Wait 20s before coming back
            timer = threading.Timer(20, self.moveTo0)
            timer.start()

            self._moving = True
    
    def robot_vel_callback(self, msg):
        if msg == Twist():
            print('Robot stopped')
            self._moving = False

    def moveToPosition(self, point):
        # Create a pose that corresponds to the final destination
        destination = self.pointToPoseStamped(point)

        # Tell robot to move to the position
        self._goal_publisher.publish(destination)


    def pointToPoseStamped(self, point):
        newPose = PoseStamped()
        newPose.pose = self.addPointToPose(newPose.pose, point)

        newPose = self.addHeaders(newPose)

        return newPose

    def pointToPoseWithCovarianceStamped(self, point):
        newPoseWithCovariance = PoseWithCovarianceStamped()
        newPoseWithCovariance.pose.pose = self.addPointToPose(newPoseWithCovariance.pose.pose, point)

        newPoseWithCovariance = self.addHeaders(newPoseWithCovariance)

        return newPoseWithCovariance
    
    def addPointToPose(self,newPose,point):
        newPose.position.x = point[0][0]
        newPose.position.y = point[0][1]

        newPose.orientation.z = point[1][0]
        newPose.orientation.w = point[1][1]

        return newPose

    def addHeaders(self, el):
        el.header.frame_id = "map"
        el.header.stamp = self.get_clock().now().to_msg()

        return el


# Main loop
def main():
    """
    Main loop
    """
    rclpy.init()
    rosNode = RobotLogic()
    rclpy.spin(rosNode)


    rosNode.destroy_node()
    rclpy.shutdown()

if __name__ == "__main__":
    main()